<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LoveTalk - 1:1 Audio Chat</title>
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        body {
            background: radial-gradient(circle at 50% 50%, #0d0d0d, #000000 80%);
            font-family: 'Orbitron', sans-serif;
            color: #0ff;
        }

        .neon-border {
            border: 2px solid #0ff;
            box-shadow: 0 0 10px #0ff, inset 0 0 10px #0ff;
        }

        .neon-btn {
            background: transparent;
            border: 2px solid #0ff;
            color: #0ff;
            transition: all 0.3s;
        }

        .neon-btn:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 20px #0ff;
        }

        .voice-bar {
            width: 10px;
            background: #0ff;
            height: 10px;
            margin: 0 2px;
            border-radius: 4px;
            transition: height 0.1s;
            box-shadow: 0 0 8px #0ff;
        }

        .voice-visualizer {
            display: flex;
            align-items: flex-end;
            height: 40px;
            justify-content: center;
        }
    </style>
</head>

<body class="flex flex-col items-center justify-center min-h-screen p-6">

    <h1 class="text-4xl font-bold mb-6 text-[#0ff] drop-shadow-lg">LoveTalk - Where Love Begins</h1>

    <div class="neon-border rounded-xl p-6 w-full max-w-md flex flex-col items-center space-y-4">

        <p class="text-sm text-[#0ff]">TURN + STUN: Auto Server Selection Enabled ðŸ”¥</p>

        <div class="w-full text-center">
            <p class="text-lg">
                Your ID:
                <span id="peerId" class="font-mono text-[#00ffff]">Initializing...</span>
            </p>
            <button id="copyPeerId" class="neon-btn px-3 py-1 mt-2 text-sm rounded">Copy</button>
        </div>

        <p id="status" class="text-center text-[#0ff]">Status: Starting...</p>

        <div id="controls" class="hidden flex space-x-3 mt-3">
            <button id="muteBtn" class="neon-btn px-4 py-1 rounded">Mute</button>
            <button id="hangupBtn"
                class="neon-btn px-4 py-1 rounded border-red-500 text-red-400 hover:bg-red-500 hover:text-black">
                Hang Up
            </button>
        </div>

        <div class="mt-6 text-center">
            <p class="text-sm text-[#0ff] mb-2">Remote Voice Level</p>
            <div id="voiceVisualizer" class="voice-visualizer"></div>
        </div>

        <div id="logs" class="bg-black/70 text-xs p-2 rounded w-full h-40 overflow-y-auto"></div>
    </div>

    <audio id="remoteAudio" autoplay></audio>

    <script>
        document.addEventListener("DOMContentLoaded", () => {
            // UI refs
            const ui = {
                logBox: document.getElementById("logs"),
                peerIdEl: document.getElementById("peerId"),
                statusEl: document.getElementById("status"),
                controlsEl: document.getElementById("controls"),
                muteBtn: document.getElementById("muteBtn"),
                hangupBtn: document.getElementById("hangupBtn"),
                copyBtn: document.getElementById("copyPeerId"),
                remoteAudio: document.getElementById("remoteAudio"),
                visualizer: document.getElementById("voiceVisualizer"),
            };

            function log(msg, level = "info") {
                const time = new Date().toLocaleTimeString();
                const line = document.createElement("div");
                line.textContent = `[${time}] ${msg}`;
                if (level === "error") line.classList.add("text-red-400");
                if (level === "warn") line.classList.add("text-yellow-300");
                ui.logBox.appendChild(line);
                ui.logBox.scrollTop = ui.logBox.scrollHeight;

                if (level === "error") console.error(msg);
                else if (level === "warn") console.warn(msg);
                else console.log(msg);
            }

            const roomId = new URLSearchParams(location.search).get("id") || "default-room";
            log("Room ID: " + roomId);

            const state = {
                peer: null,
                socket: null,
                localStream: null,
                currentCall: null,
                isMuted: false,
                analyser: null,
                pendingIncomingCall: null,
                pendingRemoteUserId: null,
                peerInitAttempts: 0,
                maxPeerInitAttempts: 3,
            };

            // ----- Socket.IO init -----
            function initSocket() {
                state.socket = io();
                state.socket.on("connect", () => {
                    log("Socket connected: " + state.socket.id);
                });
                state.socket.on("connect_error", (err) => {
                    log("Socket connect error: " + err.message, "error");
                });

                state.socket.on("user-connected", (userId) => {
                    log("User connected in room: " + userId);
                    if (!state.localStream) {
                        log("Local stream not ready yet, queue outgoing call", "warn");
                        state.pendingRemoteUserId = userId;
                        return;
                    }
                    startOutgoingCall(userId);
                });
            }

            // ----- PeerJS init with retry -----
            const iceConfig = {
                iceServers: [
                    { urls: "stun:stun.l.google.com:19302" },
                    { urls: "stun:stun1.l.google.com:19302" },
                    {
                        urls: [
                            "turn:relay1.expressturn.com:3480?transport=udp",
                            "turn:relay1.expressturn.com:3480?transport=tcp"
                        ],
                        username: "000000002078920456",
                        credential: "7au5gxraKlawrx09qC45ARXNpoM="
                    },
                    {
                        urls: [
                            "stun:bn-turn2.xirsys.com",
                            "turn:bn-turn2.xirsys.com:80?transport=udp",
                            "turn:bn-turn2.xirsys.com:3478?transport=udp",
                            "turn:bn-turn2.xirsys.com:80?transport=tcp",
                            "turn:bn-turn2.xirsys.com:3478?transport=tcp",
                            "turns:bn-turn2.xirsys.com:443?transport=tcp",
                            "turns:bn-turn2.xirsys.com:5349?transport=tcp"
                        ],
                        username:
                            "IV3rRPe9k4M8o1GyU7564eGUVmdQWRQXD5vHZIclMog1gOW9ixXSmbMYX79syFHNAAAAAGkdzuF0YXJpa3VsNzg=",
                        credential: "ef63c548-c550-11f0-b337-0242ac140004"
                    },
                ],
            };

            function initPeer() {
                if (state.peer && !state.peer.destroyed) {
                    try {
                        state.peer.destroy();
                    } catch (e) {
                        // ignore
                    }
                }

                state.peerInitAttempts += 1;
                log("Initializing PeerJS (attempt " + state.peerInitAttempts + ")");
                ui.peerIdEl.textContent = "Initializing...";

                const peer = new Peer(undefined, {
                    host: "0.peerjs.com",
                    port: 443,
                    path: "/",
                    secure: true,
                    debug: 2,
                    config: iceConfig,
                });

                state.peer = peer;

                peer.on("open", (id) => {
                    log("Peer open with ID: " + id);
                    ui.peerIdEl.textContent = id;
                    ui.statusEl.textContent = "Status: Waiting for Partner...";
                    if (state.socket && state.socket.connected) {
                        state.socket.emit("join-room", roomId, id);
                        log("Joined room via socket");
                    } else {
                        log("Socket not ready when peer opened", "warn");
                    }
                });

                peer.on("error", (err) => {
                    log("Peer error: " + err.type + " - " + err.message, "error");
                    ui.statusEl.textContent = "Status: Peer error (" + err.type + ")";
                    if (
                        (err.type === "network" || err.type === "server-error") &&
                        state.peerInitAttempts < state.maxPeerInitAttempts
                    ) {
                        log("Retrying Peer init in 2s");
                        setTimeout(initPeer, 2000);
                    }
                });

                peer.on("disconnected", () => {
                    log("Peer disconnected, trying to reconnect", "warn");
                    ui.statusEl.textContent = "Status: Reconnecting...";
                    try {
                        peer.reconnect();
                    } catch (e) {
                        log("Peer reconnect error: " + e.message, "error");
                    }
                });

                peer.on("close", () => {
                    log("Peer connection closed", "warn");
                    ui.statusEl.textContent = "Status: Peer closed";
                    if (state.peerInitAttempts < state.maxPeerInitAttempts) {
                        log("Recreating Peer instance in 2s");
                        setTimeout(initPeer, 2000);
                    }
                });

                peer.on("call", (call) => {
                    log("Incoming call from: " + call.peer);
                    if (state.currentCall) {
                        log("Already in call, closing new incoming call", "warn");
                        call.close();
                        return;
                    }
                    if (!state.localStream) {
                        log("Local stream not ready, queue incoming call", "warn");
                        state.pendingIncomingCall = call;
                        return;
                    }
                    answerCall(call);
                });
            }

            // ----- Media (mic) init -----
            function initMedia() {
                ui.statusEl.textContent = "Status: Waiting for microphone permission...";
                navigator.mediaDevices
                    .getUserMedia({ audio: true })
                    .then((stream) => {
                        state.localStream = stream;
                        ui.statusEl.textContent = "Status: Ready";
                        log("Microphone access granted");

                        // If some events came before stream
                        if (state.pendingIncomingCall) {
                            log("Processing queued incoming call");
                            answerCall(state.pendingIncomingCall);
                            state.pendingIncomingCall = null;
                        }
                        if (state.pendingRemoteUserId) {
                            log("Processing queued outgoing call to " + state.pendingRemoteUserId);
                            startOutgoingCall(state.pendingRemoteUserId);
                            state.pendingRemoteUserId = null;
                        }
                    })
                    .catch((err) => {
                        ui.statusEl.textContent = "Status: Mic permission denied";
                        log("Microphone access denied: " + err.message, "error");
                    });
            }

            // ----- Call helpers -----
            function answerCall(call) {
                state.currentCall = call;
                call.answer(state.localStream);
                setupCallHandlers(call);
            }

            function startOutgoingCall(userId) {
                if (!state.peer || state.peer.disconnected || state.peer.destroyed) {
                    log("Cannot start call, peer is not ready", "error");
                    return;
                }
                state.currentCall = state.peer.call(userId, state.localStream);
                log("Starting outgoing call to: " + userId);
                setupCallHandlers(state.currentCall);
            }

            function setupCallHandlers(call) {
                ui.statusEl.textContent = "Status: Connecting...";
                ui.controlsEl.classList.remove("hidden");

                call.on("iceStateChanged", (stateStr) => {
                    log("ICE state: " + stateStr);
                });

                if (call.peerConnection) {
                    const pc = call.peerConnection;
                    pc.addEventListener("icecandidate", (e) => {
                        if (e.candidate) {
                            log("ICE candidate type: " + e.candidate.type);
                        }
                    });
                    pc.addEventListener("connectionstatechange", () => {
                        log("PeerConnection state: " + pc.connectionState);
                    });
                }

                call.on("stream", (remoteStream) => {
                    ui.statusEl.textContent = "Status: Connected";
                    log("Remote stream received");
                    ui.remoteAudio.srcObject = remoteStream;
                    startVisualizer(remoteStream);
                });

                call.on("close", () => {
                    log("Call closed");
                    cleanupCall("Call ended");
                });

                call.on("error", (err) => {
                    log("Call error: " + err.message, "error");
                    cleanupCall("Call error");
                });
            }

            function cleanupCall(msg) {
                ui.statusEl.textContent = "Status: " + msg;
                ui.remoteAudio.srcObject = null;
                state.currentCall = null;
                ui.controlsEl.classList.add("hidden");
                ui.visualizer.innerHTML = "";
            }

            // ----- Visualizer -----
            function startVisualizer(stream) {
                const ctx = new AudioContext();
                const src = ctx.createMediaStreamSource(stream);
                const analyser = ctx.createAnalyser();
                analyser.fftSize = 64;
                src.connect(analyser);
                state.analyser = analyser;

                ui.visualizer.innerHTML = "";
                const bars = [];
                for (let i = 0; i < 16; i++) {
                    const bar = document.createElement("div");
                    bar.className = "voice-bar";
                    ui.visualizer.appendChild(bar);
                    bars.push(bar);
                }

                function render() {
                    if (!state.analyser) return;
                    const data = new Uint8Array(state.analyser.frequencyBinCount);
                    state.analyser.getByteFrequencyData(data);
                    for (let i = 0; i < bars.length; i++) {
                        bars[i].style.height = Math.max(4, data[i] / 4) + "px";
                    }
                    requestAnimationFrame(render);
                }
                render();
            }

            // ----- UI events -----
            ui.muteBtn.addEventListener("click", () => {
                if (!state.localStream) {
                    log("Mute clicked but localStream not ready", "warn");
                    return;
                }
                state.isMuted = !state.isMuted;
                state.localStream.getAudioTracks().forEach((t) => (t.enabled = !state.isMuted));
                ui.muteBtn.textContent = state.isMuted ? "Unmute" : "Mute";
                log("Mic " + (state.isMuted ? "muted" : "unmuted"));
            });

            ui.hangupBtn.addEventListener("click", () => {
                if (state.currentCall) {
                    state.currentCall.close();
                }
                cleanupCall("You hung up");
            });

            ui.copyBtn.addEventListener("click", () => {
                const id = ui.peerIdEl.textContent || "";
                if (!id || id === "Initializing...") {
                    alert("Peer ID not ready yet");
                    return;
                }
                navigator.clipboard.writeText(id);
                log("Peer ID copied to clipboard");
                alert("Peer ID copied");
            });

            // ----- Start everything -----
            initSocket();
            initMedia();
            initPeer();
        });
    </script>
</body>

</html>